/* 
KMP 算法常被称为“看毛片算法”，由一个姓K的，一个姓M的，一个姓P 一起提出。是一种由暴力匹配改进的字符串匹配算法。
KMP 是由暴力匹配改进的字符串匹配算法。那什么是暴力匹配？假若我们的目标串和模式串如下图。
（之前在 Sunday 匹配中讲过，所有的字符串匹配算法第一步都是对齐。不管是 暴力匹配，KMP，Sunday，BM 都是一样）

目标串: A B C A B D A B C E A B D
模式串: A B C E

一、暴力匹配，就是目标串和模式串一个一个的对比
目标串: A B C A B D A B C E A B D
模式串: A B C E

当A匹配成功，继续开始比对，直到我们遇见一个不匹配的字符：E，然后我们调整模式串，
从目标串的下一个字符开始匹配（注意，这里是核心）。很遗憾，还是没有匹配成功（A和B）

目标串: A B C A B D A B C E A B D
模式串: A B C E
         A B C E
           A B C E
                ......
                   A B C E

假若我们目标串长度为m，模式串长度为n。模式串与目标串至少比较m次，又因其自身长度为n，所以理论的时间复杂度为O(m*n)。
但我们可以看到，因为途中遇到不能匹配的字符时，就可以停止，并不需要完全对比（比如上图就没有全部对比）。
所以虽然理论时间复杂度为 O(m*n) ，但其实大部分情况效率高很多。

暴力匹配又称为BF算法，暴风算法。代码比较简单。


二、KMP算法
目标串: A B C A B D A B C E A B D
模式串: A B C E

最开始其实还是一样，我们依次对比A-A,B-B,C-C，直到遇见第一个无法匹配的字符A-E。

现在开始不一样了，如果按照上面的暴力匹配。此时目标串我们应该回到 B 这个位置，模式串应直接回到头。
但是按照 KMP 的思路，在我们在第一次匹配后，因为 BC 匹配成功了，所以我们知道了 BC 不等于 A（注意这个逻辑关系，如果是BA的话，就应该移动到B后面的A）。

那既然已知了 BC 不等于 A，我们就没必要用 A 和 BC 进行匹配了。那我们直接用 A 越过前面不需要匹配的 BC：
目标串: A B C A B D A B C E A B D
模式串: A B C E(x)
             A B C E

注意：为什么不移动到E的下一个？因为E和A不匹配，所以应该移动到目标串的A（模式串E）那里重新下一轮的比较（这也是下面的next数组为什么最后一个字符是没有对应的next的原因。）

继续向下适配，我们发现在 D-C 处，匹配不上了：
目标串: A B C A B D A B C E A B D
模式串: A B C E(x)
             A B C(x) E

那我们因为前面的 B 又匹配成功了，那我们就知道 B 不等于 A，所以我们又可以直接略过前面的 B（这里就利用next数组对应索引）。也就是说，我们可以直接从 D 处开始比较：
目标串: A B C A B D A B C E A B D
模式串: A B C E(x)
             A B C(x) E
                 A B C E

发现第一个D-A处，就不匹配了，继续往下对比（如果要借助next的话，那么第一个索引对应的next应该为0，回到模式串第一个比较，不过由于代码技巧，第一个索引要为-1，这是后话了）
目标串: A B C A B D A B C E A B D
模式串: A B C E(x)
             A B C(x) E
                 A B C E
                   A B C E（匹配成功，返回索引i - j）

到现在为止，你已经掌握了 KMP 的前百分之五十：【在KMP中，如果模式串和目标串没有匹配成功，目标串不回溯。】现在我们需要换一个新串，来掌握接下来的百分之五十：
我们还是从头开始匹配，直到遇到第一个不匹配的字符:

目标串: A B C A B D A B C E A B D
模式串: A B C E(x) A B B

到这里和上面的例子还是一样，因为我们的 BC 匹配成功了，所以我们知道 BC 不等于 A，所以我们可以跳过 BC（注意这个逻辑），所以我们从 A 处开始比较，直到我们再次匹配失败：
目标串: A B C A B D A B C E A B D
模式串: A B C E(x) A B B
             A B C(x) E A B B

我想到现在你已经知道怎么做了，来和我一起说。因为前面的 B 匹配成功了，所以我们知道 B 不等于 A，所以我们可以跳过 B。当然，跳过之后下一次的匹配直接失败了（A-D）。
目标串: A B C A B D A B C E A B D
模式串: A B C E(x) A B B
             A B C(x) E A B B
                 A(x) B C E A B B

重点来了！！！然后我们继续匹配下一位。我们发现这一次，我们的匹配基本就要匹配成功了，但是卡在了最后一步的比较（D-B）。
目标串: A B C A B D A B C E A B D
模式串: A B C E(x) A B B
                  ...
                   A B C E A B B(x)

现在怎么办？假若我们把两个串修改一下（把里边的AB修改成XY），那么显而易见，你当然知道从哪里开始：
目标串: A B C A B D A B C E X Y D
模式串: A B C E(x) A B B
                  ...
                   A B C E X Y B(x)
                               A(x) B C E X Y B 【从D开始比较】

但是现在的问题是，在模式串中 AB 重复出现了，那我们是不是可以在下次比较的时候直接把 AB 给让（提前匹配）出来？
所以我们把这个AB让（提前匹配）出来，让（提前匹配）出来之后，我们相当于在 模式串 上又跳过了 2个字符。
也就是说模式串下一次匹配从C开始，如何做到？模式串指针j返回到对应索引的next
目标串: A B C A B D A B C E A B D
模式串: A B C E(x) A B B
                  ...
                   A B C E A B B(x)
                           A B C(x) E A B B 【这里目标串仍然从D开始比较，只是模式串从C开始比较】

其实到这里 KMP 就基本完事了。我们可以稍微总结下：
1.如果模式串和目标串匹配成功，长串短串都加一
2.如果模式串和目标串没有匹配成功：
（1）目标串不回溯
（2）模式串回溯到匹配未成功的字符前的子串的相同的真前缀和真后缀的最大长度（也是next数组对应索引的值）

好了，我知道上面匹配成功后的第二种情况有点拗口。所以我又单独拎出来和你说。这句话是啥意思呢？

假若我们有个串 abbaab：

a, ab, abb, abba, abbaa，就是它的真前缀。
b, ab, aab, baab, bbaab, 就是它的真后缀。
“真”字，说白了就是不包含自己。

在我们上面的示例中，【未成功的字符前的子串是 ABCEAB】，它相同的最长的真前缀和真后缀就是 AB，最大长度就是2。所以我们就把模式串回溯到第2个位置处。
也就是说，模式串指针j要回溯到索引2的地方，也就是C开始比较

目标串: A B C A B D A B C E A B D
模式串: A B C E(x) A B B
                  ...
                   A B C E A B B(x)
                           A B C(x) E A B B 【A B C E A B B 匹配到最长的子串是 A B C E A B，该子串的真后缀和真前缀最大长度就是2，也就next为2】
                           0 1 2

【注意：其实这里也能理解为什么next数组对应索引的next值是根据它前一个索引的子串来生成的了，
因为到了最后一个字符，还匹配成功的话，那就是整个匹配成功了，那还用回溯什么？
只有没有匹配成功的时候，才需要将模式串的指针j回溯到指定的位置（next数组来记录这个位置）
】

看回去刚开始的例子：为什么没有回溯，而是回到了起始位置？
目标串: A B C A B D A B C E A B D
模式串: A B C E(x)
             A B C(x) E


其实这里已经回溯了，只是此时的最大长度（指的是相同真前缀和真后缀的最大长度，后面都省略）其实就是0，因此回溯到了起始位置
那我们怎么获取最大长度呢？就可以很自然的引入 next表 了：

index: 0 1 2 3 4 5 6 
       A B C E A B B
next:  0 0 0 0 0 1 2 

刚刚上面已经强调了，这是用来回溯模式串指针的表，因此它上面是指当前索引不匹配时，需要回溯的位置。
比如索引5，那就是到B不匹配，此时需要回溯的索引，就是【B的最大子串的真前缀和真后缀的最大长度】。
这个最大长度为1，因此如果到索引5不匹配，那么模式串的指针就要到索引为1，也就是第一个B的地方开始比较，而不需要到第一个A重新对比，
这里就是KMP算法的优化手段了。

到这里为止，其实 KMP 的思路已经快说完了。但是这个next匹配表的第一个索引0的next值还得再改改，不然会出问题。
举例：
             i
目标串: A B C D E F G H
模式串: A B C E(x)
             j

此时，A-E不匹配，此时j就要去查next表（ABCE的next表为0000），得到next值为0，然后j回溯为0
             i
目标串: A B C D E F G H
模式串:       A B C E
             j

这时还是不匹配（如果匹配或者next值不为0那就没事），j又去查next表，得到next为0，j又回到第一个索引，但i没变，这时候肯定还是匹配不了，又去查next表...
这样会导致死循环，因为i不变，j每次都会返回到索引0，恒定不匹配。

其实上面这种情况，如果判断结果目标串[i] !== 模式串[j]的时候，此时j根据next表索引4的next值为0，回溯到了0。
再次判断结果还是目标串[i] !== 模式串[j]，此时j根据next表索引0的next值为0，需要回溯到0，那么会造成死循环。
那如果next[0]不为0，而是改为-1，然后判断此时的j为-1的话，则i和j同时+1，继续下一项的判断，那就可以解决这个问题了~

index: 0 1 2 3
       A B C E
next: -1 0 0 0

本来index为0时，模式串为A，A不匹配的话还是要从模式串起点重新匹配的。因此next值为-1，和目标串的指针i同时+1，那就完美了
这也是为什么next表第一个是-1，而不是其他值的原因。当然不用-1，而是加一层判断那也可以。


接下来就是【next表的构建】了
模式串：X X Y X X Y X X X

我们上面说了，每一个索引对应的next值都是，前面子串的真前缀和真后缀的最大长度
首先声明两个指针i和j来进行前后缀的对比，i指向后缀，j指向前缀，一开始为-1。然后index[0]的next值如上面所说为-1
判断j是否为-1，如果是，那么这一轮就跳过回溯，i和j指针往前+1，指针往前走完之后，再更新next表的值

为什么是走完再更新而不是更新完再走呢？是因为当前索引的next值，其实是【它的子串的真前缀和真后缀的最大长度】，而不是它自己的
因此它的next值其实是子串的匹配长度对应的索引

    j  i
模式串：X X Y X X Y X X X
next  -1

检测到j为-1的时候，直接i和j都+1，然后更新i的next值0

       j i
模式串：X X Y X X Y X X X
next  -1 0

匹配成功，i和j指针继续+1，更新i指针的next值为j，也就是1，继续对比

         j i
模式串：X X Y X X Y X X X
next  -1 0 1

此时i和j不匹配，因此要把j回溯到当前j指向的索引的next值。
比如j指向索引5的时候匹配失败了，然后索引5的next值为2，那么j就回溯到索引为2中
此时j回溯到索引为0的地方

       j   i
模式串：X X Y X X Y X X X
next  -1 0 1

此时i和j仍旧不匹配，按照回溯规则，j回溯到next值，也就是索引为-1的地方

    j      i
模式串：X X Y X X Y X X X
next  -1 0 1

此时根据判断j为-1的话，就是前面没有可回溯的索引了，然后i和j指针往前+1，同时更新i的next值0

       j     i
模式串：X X Y X X Y X X X
next  -1 0 1 0

......

知道i指针走完模式串，next数组就构建完成了

模式串：X X Y X X Y X X X
next  -1 0 1 0 1 2 3 4 5


*/

// 暴力算法
function BFSearch(haystack: string, needle: string) {
  // 双指针
  let i = 0,
    j = 0;

  while (i < haystack.length && j < needle.length) {
    if (haystack[i] === needle[j]) {
      i++;
      j++;
    } else {
      // 这里加1是因为 i - j 回到比较的起点，下一次比较起点就应该+1
      i = i - j + 1;
      j = 0;
    }
  }

  // 若指针已走完模式串，表示目标串包含模式串，返回索引
  // 这里不是i - j - 1的原因是，i在最后一次的时候也++了
  if (j === needle.length) return i - j;

  return -1;
}

// KMP算法
// 构建next数组
function createNext(model: string): number[] {
  // 第一个next值默认为-1
  const next = [-1];
  // i为后缀指针，j为前缀指针
  let i = 0,
    j = -1;
  while (i < model.length) {
    if (j === -1 || model[i] === model[j]) {
      i++;
      j++;
      if (i < model.length) next[i] = j;
    } else {
      j = next[j];
    }
  }

  console.log(next);

  return next;
}

function KMPSearch(target: string, model: string): number {
  const tLen = target.length;
  const mLen = model.length;
  if (tLen === 0 || mLen === 0 || tLen < mLen) return -1;

  // 模式串对应的next表
  const next = createNext(model);

  // i为目标串指针，j为模式串指针
  let i = 0,
    j = 0;

  while (i < tLen && j < mLen) {
    if (j === -1 || target[i] === model[j]) {
      i++;
      j++;
    } else {
      j = next[j];
    }
  }

  if (j === mLen) return i - j;

  return -1;
}

console.log(KMPSearch("bbc abcdab abcdabcdabde", "abcdabd"));
